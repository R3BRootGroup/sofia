/**
 **  Macro to run the offline for all the detectors simultaneously
 **
 **  One needs to set up the Phase0 experiments, in this case s455
 **
 **  This macro takes the root files generated by the unpack_offline macro
 **  and processes the mapped data to get the next data levels (Cal and hit)
 **
 **  Author: Jose Luis <joseluis.rodriguez.sanchez@usc.es>
 **  @since May 4th, 2021
 **
 **  const Int_t nev = -1; number of events to read, -1 - until CTRL+C
 **  Select experiment ID: 444, 467 or 455
 **
 **  After defining the input file (filename), execute the macro
 **  1) if all the parameters are right by default
 **     root -l cal_offline.C
 **  2) if one wants to select a RunId, for instance 'RunId = 273'
 **     root -l 'cal_offline.C(273)'
 **  3) if one wants to select a RunId and max number of events,
 **     for instance 'RunId = 273' and 'nev = 200'
 **     root -l 'cal_offline.C(273,200)'
 **  4) if one wants to select a RunId, max number of events and ExpId,
 **     for instance 'RunId = 273', 'nev = 200', and 'ExpId = 444'
 **     root -l 'cal_offline.C(273,200,444)'
 **  Points (2), (3) and (4) are used only if runid file (setup_runid.par) is not defined
 **
 **/

TString lookforfile();

void cal_offline(const Int_t fRunId = 1, const Int_t nev = -1, const Int_t fExpId = 455)
{
    TString cRunId = Form("%04d", fRunId);
    TString cExpId = Form("%03d", fExpId);

    TStopwatch timer;

    auto t = std::time(nullptr);
    auto tm = *std::localtime(&t);
    std::ostringstream oss;
    oss << std::put_time(&tm, "%Y%m%d_%H%M%S");

    // File names and paths -----------------------------------------------------
    TString dir = gSystem->Getenv("VMCWORKDIR");
    TString filename, outputFilename, upexps_dir, ucesb_path, sofiacaldir;

    if (fExpId == 455)
    {
        // Input file
        filename = "s455_map_data_offline_2021.root";

        if (fRunId == 1 && nev == 100000) // This is for tests
            filename = lookforfile();

        TString outputpath = "/path/to/your/disk/";
        // outputFilename = outputpath + "s" + cExpId + "_cal_data_offline_" + oss.str() + ".root";
        outputFilename = "s" + cExpId + "_cal_data_offline_" + oss.str() + ".root";

        sofiacaldir = dir + "/sofia/macros/s455Up2p/parameters/";
    }
    else
    {
        std::cout << "Experiment was not selected" << std::endl;
        gApplication->Terminate();
    }

    // store data or not ------------------------------------
    Bool_t fCal_level_califa = false;  // set true if there exists a file with the calibration parameters

    // Setup: Selection of detectors ----------------------------------------------------
    // --- R3B standard -----------------------------------------------------------------
    Bool_t fNeuland = false; // NeuLAND for neutrons behind GLAD
    Bool_t fAms = false;     // AMS tracking detectors
    Bool_t fCalifa = false;  // Califa calorimeter
    Bool_t fMusic = false;   // R3B-Music: Ionization chamber for charge-Z
    // --- Sofia ------------------------------------------------------------------------
    Bool_t fMwpc0 = true;    // MWPC0 for tracking at entrance of Cave-C
    Bool_t fTrim = true;     // Triple-MUSIC for the HI beam charge-Z id, with charge-q states
    Bool_t fAt = false;      // Active Targer for Coulomb-induced fission
    Bool_t fSci = true;      // Start: Plastic scintillator for ToF
    Bool_t fMwpc1 = true;    // MWPC1 for tracking of fragments in front of target
    Bool_t fMwpc2 = true;    // MWPC2 for tracking of fragments before GLAD
    Bool_t fTwim = true;     // Twim: Ionization chamber for charge-Z of fragments
    Bool_t fMwpc3 = true;    // MWPC3 for tracking of fragments behind GLAD
    Bool_t fTofW = true;     // ToF-Wall for time-of-flight of fragments behind GLAD
    Bool_t fScalers = false; // SIS3820 scalers at Cave C
    // --- Traking ----------------------------------------------------------------------
    Bool_t fTracking = true; // Tracking of fragments inside GLAD and before GLAD

    // Calibration files for SOFIA ----------------------------------------------
    TString sofiacalfilename = sofiacaldir + "CalibParam.par";
    sofiacalfilename.ReplaceAll("//", "/");
    // Parameters for CALIFA mapping  -------------------------------------------
    TString califadir = dir + "/macros/r3b/unpack/s455/califa/parameters/";
    TString califamapfilename = califadir + "Califa_Mapping_3March2021.par";
    califamapfilename.ReplaceAll("//", "/");
    // Parameters for CALIFA calibration in keV  --------------------------------
    TString califacalfilename = califadir + "Califa_CalPar_4March2021.par";
    califacalfilename.ReplaceAll("//", "/");
    // Parameters for AMS   -----------------------------------------------------
    TString amscalfilename = sofiacaldir + "Ams_CalPar_20210312.par";
    amscalfilename.ReplaceAll("//", "/");

    // Create run  --------------------------------------------------------------
    FairRunAna* run = new FairRunAna();
    // Set up R3BHeader  --------------------------------------------------------
    R3BEventHeader* EvntHeader = new R3BEventHeader();
    run->SetEventHeader(EvntHeader);
    // run->SetRunId(fRunId);
    run->SetSink(new FairRootFileSink(outputFilename));

    // Runtime data base ------------------------------------
    FairRuntimeDb* rtdb = run->GetRuntimeDb();

    // Ascii file with parameters
    FairParAsciiFileIo* parIo1 = new FairParAsciiFileIo();
    TList* parList1 = new TList();
    parList1->Add(new TObjString(sofiacalfilename));
    if (fCalifa)
    {
        if (fCal_level_califa)
            parList1->Add(new TObjString(califacalfilename));
        else
            parList1->Add(new TObjString(califamapfilename));
    }
    if (fAms)
        parList1->Add(new TObjString(amscalfilename));
    parIo1->open(parList1);
    rtdb->setFirstInput(parIo1);
    rtdb->print();

    // Create source using root files for input ---------------------------------
    R3BFileSource* source = new R3BFileSource(filename);
    source->SetInputFileName("./parameters/setup_runid.par");
    source->SetRunId(fRunId);
    run->SetSource(source);

    // Add analysis task --------------------------------------------------------

    // Add Header copy
    R3BEventHeaderPropagator* RunIdTask = new R3BEventHeaderPropagator();
    run->AddTask(RunIdTask);

    // Add WRs from sofia
    R3BWhiterabbitPropagator* wrsofia = new R3BWhiterabbitPropagator("SofWhiterabbitPropagator", 1, "SofWR");
    run->AddTask(wrsofia);

    // MWPC0
    if (fMwpc0)
    {
        R3BSofMwpc0Mapped2Cal* MW0Map2Cal = new R3BSofMwpc0Mapped2Cal();
        run->AddTask(MW0Map2Cal);

        R3BSofMwpc0Cal2Hit* MW0Cal2Hit = new R3BSofMwpc0Cal2Hit();
        run->AddTask(MW0Cal2Hit);
    }

    // SCI
    if (fSci)
    {
        // --- Mapped 2 Tcal for SofSci
        R3BSofSciMapped2Tcal* SofSciMap2Tcal = new R3BSofSciMapped2Tcal();
        run->AddTask(SofSciMap2Tcal);

        // --- Tcal 2 SingleTcal for SofSci
        R3BSofSciTcal2SingleTcal* SofSciTcal2STcal = new R3BSofSciTcal2SingleTcal();
        run->AddTask(SofSciTcal2STcal);

        // --- SingleTcal 2 Cal for SofSci
        R3BSofSciSingleTcal2Cal* SofSciSTcal2Cal = new R3BSofSciSingleTcal2Cal();
        run->AddTask(SofSciSTcal2Cal);

        // --- SingleTcal 2 Hit for SofSci
        R3BSofSciSingleTcal2Hit* SofSciSTcal2Hit = new R3BSofSciSingleTcal2Hit();
        SofSciSTcal2Hit->SetCalParams(675., -1922.); // ToF calibration at Cave-C
        run->AddTask(SofSciSTcal2Hit);
    }

    // Triple-MUSIC
    if (fTrim)
    {
        // --- Mapped 2 Cal
        R3BSofTrimMapped2Cal* SofTrimMap2Cal = new R3BSofTrimMapped2Cal();
        run->AddTask(SofTrimMap2Cal);

        // --- Cal 2 Hit
        R3BSofTrimCal2Hit* SofTrimCal2Hit = new R3BSofTrimCal2Hit();
        SofTrimCal2Hit->SetExpId(fExpId);
        SofTrimCal2Hit->SetCoulex(kFALSE);
        SofTrimCal2Hit->SetTriShape(kTRUE);
        run->AddTask(SofTrimCal2Hit);
    }

    // AMS
    if (fAms)
    {
        // R3BWhiterabbitPropagator ---
        R3BWhiterabbitPropagator* wrams = new R3BWhiterabbitPropagator("AmsWhiterabbitPropagator", 1, "WRAms");
        run->AddTask(wrams);
        R3BAmsMapped2StripCal* AmsMap2Cal = new R3BAmsMapped2StripCal();
        run->AddTask(AmsMap2Cal);
        R3BAmsStripCal2Hit* AmsCal2Hit = new R3BAmsStripCal2Hit();
        run->AddTask(AmsCal2Hit);
    }

    // CALIFA
    if (fCalifa && fCal_level_califa)
    {
        // R3BWhiterabbitPropagator ---
        R3BWhiterabbitPropagator* wrcalifa = new R3BWhiterabbitPropagator("CalifaWhiterabbitPropagator", 1, "WRCalifa");
        run->AddTask(wrcalifa);
        // R3BCalifaMapped2CrystalCal ---
        R3BCalifaMapped2CrystalCal* CalifaMap2Cal = new R3BCalifaMapped2CrystalCal();
        run->AddTask(CalifaMap2Cal);
        // R3BCalifaCrystalCal2Hit ---
        R3BCalifaCrystalCal2Hit* CalifaCal2Hit = new R3BCalifaCrystalCal2Hit();
        CalifaCal2Hit->SetCrystalThreshold(350.); // 100keV
        CalifaCal2Hit->SetDRThreshold(20000.);    // 10MeV
        CalifaCal2Hit->SelectGeometryVersion(2021);
        run->AddTask(CalifaCal2Hit);
    }

    // MWPC1
    if (fMwpc1)
    {
        R3BSofMwpc1Mapped2Cal* MW1Map2Cal = new R3BSofMwpc1Mapped2Cal();
        run->AddTask(MW1Map2Cal);

        R3BSofMwpc1Cal2Hit* MW1Cal2Hit = new R3BSofMwpc1Cal2Hit();
        run->AddTask(MW1Cal2Hit);
    }

    // MWPC2
    if (fMwpc2)
    {
        R3BSofMwpc2Mapped2Cal* MW2Map2Cal = new R3BSofMwpc2Mapped2Cal();
        run->AddTask(MW2Map2Cal);

        R3BSofMwpc2Cal2Hit* MW2Cal2Hit = new R3BSofMwpc2Cal2Hit();
        run->AddTask(MW2Cal2Hit);
    }

    // MWPC3
    if (fMwpc3)
    {
        R3BSofMwpc3Mapped2Cal* MW3Map2Cal = new R3BSofMwpc3Mapped2Cal();
        run->AddTask(MW3Map2Cal);

        R3BSofMwpc3Cal2Hit* MW3Cal2Hit = new R3BSofMwpc3Cal2Hit();
        run->AddTask(MW3Cal2Hit);
    }

    // ToF-Wall
    if (fTofW)
    {
        // --- Mapped 2 Tcal for SofTofW
        R3BSofTofWMapped2Tcal* SofTofWMap2Tcal = new R3BSofTofWMapped2Tcal();
        run->AddTask(SofTofWMap2Tcal);

        // --- Tcal 2 SingleTcal for SofTofW
        R3BSofTofWTcal2SingleTcal* SofTofWTcal2STcal = new R3BSofTofWTcal2SingleTcal();
        run->AddTask(SofTofWTcal2STcal);

        // --- SingleTcal 2 Hit for SofTofW
        R3BSofTofWSingleTCal2Hit* SofTofWSingleTcal2Hit = new R3BSofTofWSingleTCal2Hit();
        SofTofWSingleTcal2Hit->SetExpId(fExpId);
        SofTofWSingleTcal2Hit->SetTofLISE(33.);
        run->AddTask(SofTofWSingleTcal2Hit);
    }

    // TWIM
    if (fTwim)
    {
        R3BSofTwimMapped2Cal* TwimMap2Cal = new R3BSofTwimMapped2Cal();
        TwimMap2Cal->SetExpId(fExpId);
        run->AddTask(TwimMap2Cal);

        R3BSofTwimCal2Hit* TwimCal2Hit = new R3BSofTwimCal2Hit();
        TwimCal2Hit->SetExpId(fExpId);
        run->AddTask(TwimCal2Hit);
    }

    // Tracking
    if (fMwpc2 && fMwpc3 && fTofW && fTwim && fSci && fTracking)
    {
        R3BSofFissionAnalysis* TrackingAna = new R3BSofFissionAnalysis();
        run->AddTask(TrackingAna);
    }

    // Initialize -------------------------------------------
    timer.Start();
    run->Init();
    FairLogger::GetLogger()->SetLogScreenLevel("INFO");

    // Run --------------------------------------------------
    if (nev > -1)
        run->Run(nev);
    else
        run->Run();

    // Finish -----------------------------------------------
    timer.Stop();
    Double_t rtime = timer.RealTime() / 60.;
    Double_t ctime = timer.CpuTime() / 60.;
    std::cout << std::endl << std::endl;
    std::cout << "Macro finished succesfully." << std::endl;
    std::cout << "Output file is " << outputFilename << std::endl;
    std::cout << "Real time " << rtime << " min, CPU time " << ctime << " min" << std::endl << std::endl;
    gApplication->Terminate();
}

TString lookforfile()
{
    // This looks for root files in a directory defined below:
    TString directory = "./";

    TString filename;
    TString base = "s455_map_data_offline_([0-9]+)_([0-9]*)\\.root";

    TPRegexp regexp(base);

    std::cout << "Base: " << base << std::endl;
    std::cout << "Looking for datafiles in " << directory << std::endl;
    void* dirp = gSystem->OpenDirectory(directory);
    Char_t* afile;
    while ((afile = const_cast<Char_t*>(gSystem->GetDirEntry(dirp))))
    {
        TObjArray* objArray = regexp.MatchS(afile);
        if (objArray->At(0))
        { // match
            filename = directory + ((TObjString*)objArray->At(0))->GetString();
            std::cout << "Filename: " << filename << std::endl;
        }
        delete objArray;
    }
    return filename;
}
